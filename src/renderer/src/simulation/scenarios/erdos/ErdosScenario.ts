import {
    Scenario,
    ScenarioMetadata,
    ControlSignal,
    TelemetryPoint,
    ScenarioEvent
} from '../../types';
import { PRNG } from '../../../common/prng';
import {
    DEFAULT_ERDOS_CONFIG,
    DiscoveryAgent,
    ErdosConfig,
    ErdosProblem,
    ErdosState,
    ProblemDomain
} from './ErdosTypes';

const PROBLEM_BANK: Array<Omit<ErdosProblem, 'solved' | 'solutionQuality' | 'lastStatusUpdate' | 'steps' | 'agents' | 'copyAction'>> = [
    {
        id: 'erdos-distinct-distances',
        title: 'Distinct distances on the plane (minimum distinct distance growth)',
        description: 'Determine tight asymptotic lower bounds for the minimum number of distinct pairwise distances determined by n planar points.',
        domain: 'geometry',
        difficulty: 0.82,
        reward: 500
    },
    {
        id: 'erdos-discrepancy',
        title: 'Discrepancy growth for bounded-sign arithmetic progressions',
        description: 'Characterize growth rates for discrepancy in ±1 colorings restricted to arithmetic progressions with bounded signs.',
        domain: 'additive_number_theory',
        difficulty: 0.86,
        reward: 600
    },
    {
        id: 'erdos-turan-cubes',
        title: 'Turán density of 3-uniform hypergraph K4(3)',
        description: 'Estimate or pin down the extremal edge density threshold forbidding K4(3) in 3-uniform hypergraphs.',
        domain: 'combinatorics',
        difficulty: 0.9,
        reward: 700
    },
    {
        id: 'erdos-faber-lovasz',
        title: 'Erdős–Faber–Lovász coloring threshold dynamics',
        description: 'Track conditions under which near-linear hypergraph intersection structures satisfy chromatic bounds predicted by Erdős–Faber–Lovász.',
        domain: 'graph_theory',
        difficulty: 0.75,
        reward: 300
    },
    {
        id: 'erdos-unit-distance',
        title: 'Maximum unit distances among n planar points',
        description: 'Improve upper and lower bounds for the maximum number of unit distances among n points in the Euclidean plane.',
        domain: 'geometry',
        difficulty: 0.74,
        reward: 250
    },
    {
        id: 'erdos-szemeredi-sum-product',
        title: 'Sum-product lower bound exponent improvements',
        description: 'Strengthen exponent bounds in finite-set sum-product inequalities over integers and reals.',
        domain: 'additive_number_theory',
        difficulty: 0.8,
        reward: 400
    },
    {
        id: 'erdos-hajnal',
        title: 'Erdős–Hajnal exponent amplification in forbidden-subgraph classes',
        description: 'Quantify how forbidden subgraph families amplify the Erdős–Hajnal exponent and produce larger homogeneous sets.',
        domain: 'graph_theory',
        difficulty: 0.78,
        reward: 450
    },
    {
        id: 'erdos-moser',
        title: 'Distinct subset-sum lower bounds for sparse integer sets',
        description: 'Find sharper lower bounds for the number of distinct subset sums generated by sparse structured integer sets.',
        domain: 'combinatorics',
        difficulty: 0.72,
        reward: 220
    },

    {
        id: 'erdos-littlewood-offord',
        title: 'Littlewood–Offord anti-concentration refinements',
        description: 'Sharpen anti-concentration bounds for random signed sums with structured coefficient sets.',
        domain: 'additive_number_theory',
        difficulty: 0.81,
        reward: 420
    },
    {
        id: 'erdos-ginzburg-ziv-variants',
        title: 'Erdős–Ginzburg–Ziv extremal threshold variants',
        description: 'Improve extremal constants and structure theorems around zero-sum subsequences in finite abelian groups.',
        domain: 'additive_number_theory',
        difficulty: 0.79,
        reward: 360
    },
    {
        id: 'erdos-ko-rado-stability',
        title: 'Erdős–Ko–Rado stability and supersaturation bounds',
        description: 'Quantify stability gaps and supersaturation rates in intersecting-family extremal regimes.',
        domain: 'combinatorics',
        difficulty: 0.76,
        reward: 340
    },
    {
        id: 'erdos-hecke-lattice-points',
        title: 'Lattice-point discrepancy on convex curves',
        description: 'Strengthen discrepancy estimates for lattice points near convex planar curves with arithmetic structure.',
        domain: 'geometry',
        difficulty: 0.83,
        reward: 480
    },
    {
        id: 'erdos-gallai-path-cover',
        title: 'Erdős–Gallai path/degree extremal refinements',
        description: 'Tighten extremal edge thresholds for long paths and degree-sequence realizability constraints.',
        domain: 'graph_theory',
        difficulty: 0.74,
        reward: 300
    },
    {
        id: 'erdos-moser-equation',
        title: 'Erdős–Moser equation exclusion bounds',
        description: 'Advance exclusion bounds and structural impossibility arguments for Erdős–Moser-type exponential Diophantine equations.',
        domain: 'additive_number_theory',
        difficulty: 0.91,
        reward: 760
    },
    {
        id: 'erdos-regularity-removal',
        title: 'Regularity/removal quantitative constants',
        description: 'Improve quantitative dependence in graph/hypergraph removal lemmas relevant to Erdős-style extremal questions.',
        domain: 'graph_theory',
        difficulty: 0.88,
        reward: 650
    },
    {
        id: 'erdos-rado-sunflower',
        title: 'Sunflower threshold exponent improvements',
        description: 'Push exponent bounds for sunflower-free set systems and identify sharper transition behavior.',
        domain: 'combinatorics',
        difficulty: 0.84,
        reward: 520
    }
];


const DOMAINS: ProblemDomain[] = ['additive_number_theory', 'combinatorics', 'graph_theory', 'geometry'];

const buildCopyAction = (problem: ErdosProblem): string => {
    const statusLine = problem.solved ? '**Status:** Solved' : '**Status:** In progress';
    const steps = problem.steps.length > 0
        ? problem.steps.map((step, index) => `${index + 1}. ${step}`).join('\n')
        : problem.solved
            ? '1. No explicit step trace captured.'
            : '1. No step trace available yet.';

    return [
        `**Problem:** ${problem.title}`,
        `**Description:** ${problem.description}`,
        statusLine,
        '**Steps:**',
        steps
    ].join('\n');
};

const buildInitialSteps = (domain: ProblemDomain): string[] => {
    const reproducibilityTail = [
        'Record all assumptions, notation, and known lemmas with exact references so another team can reproduce the same starting state.',
        'Define explicit acceptance criteria (target inequality, error tolerance, and verification checks) before declaring progress.'
    ];

    switch (domain) {
        case 'geometry':
            return [
                'Collect candidate geometric constructions and identify extremal configurations.',
                'Test bounds using distance-incidence arguments and compare with known asymptotics.',
                'Provide coordinate-level construction data and computational scripts for each candidate extremal family.',
                ...reproducibilityTail
            ];
        case 'graph_theory':
            return [
                'Enumerate structural graph constraints induced by the conjecture conditions.',
                'Search for extremal or forbidden patterns that tighten combinatorial bounds.',
                'Submit machine-checkable certificates (edge lists, SAT encodings, or proof scripts) for each claimed obstruction.',
                ...reproducibilityTail
            ];
        case 'combinatorics':
            return [
                'Map the problem to an equivalent counting formulation with explicit constraints.',
                'Apply probabilistic and extremal estimates to narrow feasible bound ranges.',
                'Publish exact counting pipelines and random-seed controls for every Monte Carlo or probabilistic estimate.',
                ...reproducibilityTail
            ];
        case 'additive_number_theory':
        default:
            return [
                'Translate the statement into additive-combinatorial inequalities over candidate sets.',
                'Probe edge cases via residue classes and growth-rate heuristics.',
                'Archive computational experiments with full parameter sweeps and independent rerun instructions.',
                ...reproducibilityTail
            ];
    }
};


export class ErdosScenario implements Scenario<ErdosConfig> {
    public metadata: ScenarioMetadata = {
        id: 'erdos',
        name: 'Erdős Open Problems',
        description: 'Evolving discovery agencies collaborate on the Erdős open-problem catalog (teorth/erdosproblems) and expand the cognitive light cone.',
        version: '0.1.0',
        type: 'erdos'
    };

    private state: ErdosState;
    private config: ErdosConfig;
    private prng: PRNG;
    private eventQueue: ScenarioEvent[] = [];

    constructor() {
        this.prng = new PRNG(Date.now());
        this.config = { ...DEFAULT_ERDOS_CONFIG };
        this.state = this.getEmptyState();
    }

    private getEmptyState(): ErdosState {
        return {
            generation: 0,
            cycle: 1,
            nextProblemIndex: 0,
            agents: [],
            activeProblems: [],
            solvedProblems: [],
            metrics: {
                C: 0,
                D: 0,
                A: 0,
                U: 0,
                alertRate: 0,
                solvedRatio: 0,
                activeProblems: 0,
                cumulativeReward: 0,
                cognitiveLightCone: 0
            }
        };
    }

    private randomAgent(index: number): DiscoveryAgent {
        return {
            id: `agency-${this.state.generation}-${index}-${Math.floor(this.prng.next() * 1e6)}`,
            specialization: DOMAINS[this.prng.nextInt(0, DOMAINS.length)],
            creativity: 0.35 + this.prng.next() * 0.55,
            rigor: 0.35 + this.prng.next() * 0.55,
            collaboration: 0.2 + this.prng.next() * 0.7,
            solvedCount: 0
        };
    }

    private reseedProblems() {
        if (this.state.activeProblems.length > 0) {
            return;
        }

        if (this.state.nextProblemIndex >= PROBLEM_BANK.length) {
            this.state.nextProblemIndex = 0;
            this.state.cycle += 1;
            this.eventQueue.push({
                type: 'task_solved',
                timestamp: this.state.generation,
                data: { cycle: this.state.cycle },
                message: `Starting verification cycle ${this.state.cycle} across the full Erdős problem catalog.`
            });
        }

        const now = new Date().toISOString();
        const nextProblem = PROBLEM_BANK[this.state.nextProblemIndex];
        const seededProblem: ErdosProblem = {
            ...nextProblem,
            solved: false,
            solutionQuality: 0,
            lastStatusUpdate: now,
            steps: [...buildInitialSteps(nextProblem.domain), `Cycle ${this.state.cycle}: baseline investigation initialized.`],
            agents: [],
            copyAction: ''
        };
        seededProblem.copyAction = buildCopyAction(seededProblem);

        this.state.activeProblems = [seededProblem];
        this.state.nextProblemIndex += 1;
    }

    public initialize(seed: number, config?: ErdosConfig): void {
        this.prng.setSeed(seed);
        this.config = { ...DEFAULT_ERDOS_CONFIG, ...(config || {}) };
        this.state = this.getEmptyState();

        for (let i = 0; i < this.config.populationSize; i++) {
            this.state.agents.push(this.randomAgent(i));
        }

        this.reseedProblems();
    }

    public updateConfig(config: Partial<ErdosConfig>): void {
        const next = { ...this.config, ...config };
        next.populationSize = Math.max(1, Math.floor(next.populationSize));
        next.problemsPerGeneration = 1;
        next.mutationRate = Math.max(0, Math.min(1, next.mutationRate));
        next.collaborationBoost = Math.max(0, Math.min(1, next.collaborationBoost));
        this.config = next;
    }

    public step(control: ControlSignal): void {
        this.state.generation += 1;

        if (this.state.activeProblems.length === 0) {
            this.reseedProblems();
        }

        let newlySolved = 0;
        let reward = 0;
        const collaborationFactor = control.U * this.config.collaborationBoost;

        for (const problem of this.state.activeProblems) {
            const specialists = this.state.agents.filter(agent => agent.specialization === problem.domain);
            const squad = specialists.length > 0 ? specialists : this.state.agents;
            const contributorCount = Math.max(1, Math.floor(squad.length * (0.2 + collaborationFactor * 0.4)));
            const contributors = [...squad].sort(() => this.prng.next() - 0.5).slice(0, contributorCount);
            const contributorRoster = contributors.map(agent => ({
                id: agent.id,
                name: `Agent ${agent.id.slice(-6)}`
            }));

            const avgCreativity = contributors.reduce((acc, a) => acc + a.creativity, 0) / contributors.length;
            const avgRigor = contributors.reduce((acc, a) => acc + a.rigor, 0) / contributors.length;
            const avgCollab = contributors.reduce((acc, a) => acc + a.collaboration, 0) / contributors.length;

            const basePower = avgCreativity * 0.45 + avgRigor * 0.45 + avgCollab * 0.1;
            const pressureBonus = control.U * 0.15;
            const noise = (this.prng.next() - 0.5) * 0.08;
            const solutionQuality = Math.max(0, Math.min(1, basePower + pressureBonus + noise));
            const threshold = problem.difficulty * (0.85 - collaborationFactor * 0.2);

            problem.solutionQuality = solutionQuality;
            problem.lastStatusUpdate = new Date().toISOString();
            problem.agents = contributorRoster;
            problem.steps = [
                ...problem.steps,
                `Generation ${this.state.generation}: Contributors tested a ${problem.domain.replace(/_/g, ' ')} strategy and reached quality ${solutionQuality.toFixed(3)}.`,
                `Generation ${this.state.generation}: Reproducibility package updated with data/proof artifacts, verification commands, and reviewer checklist.`
            ];
            if (solutionQuality >= threshold) {
                problem.steps = [
                    ...problem.steps,
                    `Generation ${this.state.generation}: Threshold ${threshold.toFixed(3)} met; result marked as solved.`,
                    `Generation ${this.state.generation}: Added peer-review summary including independent replication status and unresolved proof obligations.`
                ];
                problem.solved = true;
                newlySolved += 1;
                reward += problem.reward;
                contributors.forEach(agent => {
                    agent.solvedCount += 1;
                });

                this.eventQueue.push({
                    type: 'task_solved',
                    timestamp: this.state.generation,
                    data: {
                        problemId: problem.id,
                        title: problem.title,
                        domain: problem.domain,
                        quality: solutionQuality
                    },
                    message: `Solved: ${problem.title}`
                });
            }

            problem.copyAction = buildCopyAction(problem);
        }

        const solvedThisRound = this.state.activeProblems.filter(problem => problem.solved);
        if (solvedThisRound.length > 0) {
            const solvedById = new Map(this.state.solvedProblems.map(problem => [problem.id, problem] as const));
            solvedThisRound.forEach(problem => {
                solvedById.set(problem.id, problem);
            });
            this.state.solvedProblems = Array.from(solvedById.values());
        }
        this.state.activeProblems = this.state.activeProblems.filter(problem => !problem.solved);

        const solvedProblemIds = new Set(this.state.solvedProblems.map(problem => problem.id));
        const solvedRatio = Math.min(1, solvedProblemIds.size / PROBLEM_BANK.length);
        const specializationSpread = new Set(this.state.agents.map(agent => agent.specialization)).size / DOMAINS.length;
        const avgCollab = this.state.agents.reduce((sum, agent) => sum + agent.collaboration, 0) / this.state.agents.length;
        const avgSkill = this.state.agents.reduce((sum, agent) => sum + (agent.creativity + agent.rigor) / 2, 0) / this.state.agents.length;
        const cognitiveLightCone = Math.min(1, solvedRatio * 0.6 + avgCollab * 0.25 + control.U * 0.15);

        this.state.metrics.C = Math.max(0, Math.min(1, 0.5 * avgSkill + 0.5 * solvedRatio));
        this.state.metrics.D = Math.max(0, Math.min(1, specializationSpread));
        this.state.metrics.A = Math.max(0, Math.min(1, 0.5 * solvedRatio + 0.3 * avgCollab + 0.2 * control.U));
        this.state.metrics.U = control.U;
        this.state.metrics.alertRate = this.state.metrics.A > 0.75 ? this.state.metrics.alertRate * 0.8 + 0.2 : this.state.metrics.alertRate * 0.9;
        this.state.metrics.solvedRatio = solvedRatio;
        this.state.metrics.activeProblems = this.state.activeProblems.length;
        this.state.metrics.cumulativeReward += reward;
        this.state.metrics.cognitiveLightCone = cognitiveLightCone;

        this.state.agents = this.state.agents.map((agent, index) => {
            if (this.prng.next() > this.config.mutationRate) return agent;
            return {
                ...agent,
                creativity: Math.max(0, Math.min(1, agent.creativity + (this.prng.next() - 0.5) * 0.15)),
                rigor: Math.max(0, Math.min(1, agent.rigor + (this.prng.next() - 0.5) * 0.15)),
                collaboration: Math.max(0, Math.min(1, agent.collaboration + (this.prng.next() - 0.5) * 0.15)),
                specialization: this.prng.next() < 0.15 ? DOMAINS[this.prng.nextInt(0, DOMAINS.length)] : agent.specialization,
                id: `${agent.id.split('-')[0]}-${this.state.generation}-${index}-${Math.floor(this.prng.next() * 1e6)}`
            };
        });

        if (newlySolved > 0 && this.state.metrics.A >= 0.7) {
            this.eventQueue.push({
                type: 'agent_emerged',
                timestamp: this.state.generation,
                data: {
                    id: `erdos-agency-${this.state.generation}`,
                    timestamp: new Date().toISOString(),
                    name: 'Erdős Discovery Collective',
                    description: `Collective solved ${newlySolved} open problems this generation with cognitive light cone ${cognitiveLightCone.toFixed(2)}.`,
                    tags: ['Erdos', 'Open-Problems', 'Cognitive-Light-Cone'],
                    generation: this.state.generation,
                    metrics: {
                        A: this.state.metrics.A,
                        C: this.state.metrics.C,
                        D: this.state.metrics.D,
                        alertRate: this.state.metrics.alertRate,
                        cognitiveHorizon: cognitiveLightCone,
                        competency: solvedRatio
                    },
                    parameters: this.config,
                    environmentalControl: { U: control.U },
                    historySnippet: [],
                    validationMetrics: {
                        stateBoundsViolationRate: 0,
                        diversityFloorViolationFraction: 0,
                        controlBoundsViolationRate: 0
                    },
                    runContext: {
                        bestAgencySoFar: this.state.metrics.A
                    }
                },
                message: 'New Erdős discovery agency added to library'
            });
        }

        if (this.state.activeProblems.length === 0) {
            this.reseedProblems();
        }
    }

    public getMetrics(): TelemetryPoint {
        return {
            generation: this.state.generation,
            C: this.state.metrics.C,
            D: this.state.metrics.D,
            A: this.state.metrics.A,
            U: this.state.metrics.U,
            alertRate: this.state.metrics.alertRate
        };
    }

    public getState(): ErdosState {
        return this.state;
    }

    public serialize(): string {
        return JSON.stringify(this.state);
    }

    public deserialize(state: string): void {
        const parsed = JSON.parse(state) as Partial<ErdosState>;
        this.state = {
            ...this.getEmptyState(),
            ...parsed,
            cycle: typeof parsed.cycle === 'number' ? Math.max(1, Math.floor(parsed.cycle)) : 1,
            nextProblemIndex: typeof parsed.nextProblemIndex === 'number'
                ? Math.max(0, Math.floor(parsed.nextProblemIndex))
                : Array.isArray(parsed.solvedProblems)
                    ? parsed.solvedProblems.length
                    : 0
        };

        if (!Array.isArray(this.state.activeProblems)) {
            this.state.activeProblems = [];
        }

        if (this.state.activeProblems.length > 1) {
            this.state.activeProblems = [this.state.activeProblems[0]];
        }

        const solvedById = new Map<string, ErdosProblem>();
        (Array.isArray(this.state.solvedProblems) ? this.state.solvedProblems : []).forEach(problem => {
            const existing = solvedById.get(problem.id);
            if (!existing) {
                solvedById.set(problem.id, problem);
                return;
            }
            const existingTimestamp = Date.parse(existing.lastStatusUpdate || '');
            const incomingTimestamp = Date.parse(problem.lastStatusUpdate || '');
            if (incomingTimestamp >= existingTimestamp) {
                solvedById.set(problem.id, problem);
            }
        });
        this.state.solvedProblems = Array.from(solvedById.values());
    }

    public getEvents(): ScenarioEvent[] {
        return [...this.eventQueue];
    }

    public clearEvents(): void {
        this.eventQueue = [];
    }
}
