import {
    Scenario,
    ScenarioMetadata,
    ControlSignal,
    TelemetryPoint,
    ScenarioEvent
} from '../../types';
import { PRNG } from '../../../common/prng';
import {
    DEFAULT_ERDOS_CONFIG,
    DiscoveryAgent,
    ErdosConfig,
    ErdosProblem,
    ErdosState,
    ProblemDomain
} from './ErdosTypes';

const PROBLEM_BANK: Array<Omit<ErdosProblem, 'solved' | 'solutionQuality' | 'lastStatusUpdate' | 'steps' | 'agents' | 'copyAction' | 'resolutionReportMarkdown'>> = [
    {
        id: 'erdos-distinct-distances',
        erdosNumber: 335,
        title: 'Distinct distances on the plane (minimum distinct distance growth)',
        description: 'Determine tight asymptotic lower bounds for the minimum number of distinct pairwise distances determined by n planar points.',
        domain: 'geometry',
        difficulty: 0.82,
        reward: 500
    },
    {
        id: 'erdos-discrepancy',
        erdosNumber: 66,
        title: 'Discrepancy growth for bounded-sign arithmetic progressions',
        description: 'Characterize growth rates for discrepancy in ±1 colorings restricted to arithmetic progressions with bounded signs.',
        domain: 'additive_number_theory',
        difficulty: 0.86,
        reward: 600
    },
    {
        id: 'erdos-turan-cubes',
        erdosNumber: 319,
        title: 'Turán density of 3-uniform hypergraph K4(3)',
        description: 'Estimate or pin down the extremal edge density threshold forbidding K4(3) in 3-uniform hypergraphs.',
        domain: 'combinatorics',
        difficulty: 0.9,
        reward: 700
    },
    {
        id: 'erdos-faber-lovasz',
        erdosNumber: 521,
        title: 'Erdős–Faber–Lovász coloring threshold dynamics',
        description: 'Track conditions under which near-linear hypergraph intersection structures satisfy chromatic bounds predicted by Erdős–Faber–Lovász.',
        domain: 'graph_theory',
        difficulty: 0.75,
        reward: 300
    },
    {
        id: 'erdos-unit-distance',
        erdosNumber: 120,
        title: 'Maximum unit distances among n planar points',
        description: 'Improve upper and lower bounds for the maximum number of unit distances among n points in the Euclidean plane.',
        domain: 'geometry',
        difficulty: 0.74,
        reward: 250
    },
    {
        id: 'erdos-szemeredi-sum-product',
        erdosNumber: 206,
        title: 'Sum-product lower bound exponent improvements',
        description: 'Strengthen exponent bounds in finite-set sum-product inequalities over integers and reals.',
        domain: 'additive_number_theory',
        difficulty: 0.8,
        reward: 400
    },
    {
        id: 'erdos-hajnal',
        erdosNumber: 217,
        title: 'Erdős–Hajnal exponent amplification in forbidden-subgraph classes',
        description: 'Quantify how forbidden subgraph families amplify the Erdős–Hajnal exponent and produce larger homogeneous sets.',
        domain: 'graph_theory',
        difficulty: 0.78,
        reward: 450
    },
    {
        id: 'erdos-moser',
        erdosNumber: 288,
        title: 'Distinct subset-sum lower bounds for sparse integer sets',
        description: 'Find sharper lower bounds for the number of distinct subset sums generated by sparse structured integer sets.',
        domain: 'combinatorics',
        difficulty: 0.72,
        reward: 220
    },

    {
        id: 'erdos-littlewood-offord',
        erdosNumber: 744,
        title: 'Littlewood–Offord anti-concentration refinements',
        description: 'Sharpen anti-concentration bounds for random signed sums with structured coefficient sets.',
        domain: 'additive_number_theory',
        difficulty: 0.81,
        reward: 420
    },
    {
        id: 'erdos-ginzburg-ziv-variants',
        erdosNumber: 912,
        title: 'Erdős–Ginzburg–Ziv extremal threshold variants',
        description: 'Improve extremal constants and structure theorems around zero-sum subsequences in finite abelian groups.',
        domain: 'additive_number_theory',
        difficulty: 0.79,
        reward: 360
    },
    {
        id: 'erdos-ko-rado-stability',
        erdosNumber: 836,
        title: 'Erdős–Ko–Rado stability and supersaturation bounds',
        description: 'Quantify stability gaps and supersaturation rates in intersecting-family extremal regimes.',
        domain: 'combinatorics',
        difficulty: 0.76,
        reward: 340
    },
    {
        id: 'erdos-hecke-lattice-points',
        erdosNumber: 1096,
        title: 'Lattice-point discrepancy on convex curves',
        description: 'Strengthen discrepancy estimates for lattice points near convex planar curves with arithmetic structure.',
        domain: 'geometry',
        difficulty: 0.83,
        reward: 480
    },
    {
        id: 'erdos-gallai-path-cover',
        erdosNumber: 987,
        title: 'Erdős–Gallai path/degree extremal refinements',
        description: 'Tighten extremal edge thresholds for long paths and degree-sequence realizability constraints.',
        domain: 'graph_theory',
        difficulty: 0.74,
        reward: 300
    },
    {
        id: 'erdos-moser-equation',
        erdosNumber: 70,
        title: 'Erdős–Moser equation exclusion bounds',
        description: 'Advance exclusion bounds and structural impossibility arguments for Erdős–Moser-type exponential Diophantine equations.',
        domain: 'additive_number_theory',
        difficulty: 0.91,
        reward: 760
    },
    {
        id: 'erdos-regularity-removal',
        erdosNumber: 1155,
        title: 'Regularity/removal quantitative constants',
        description: 'Improve quantitative dependence in graph/hypergraph removal lemmas relevant to Erdős-style extremal questions.',
        domain: 'graph_theory',
        difficulty: 0.88,
        reward: 650
    },
    {
        id: 'erdos-rado-sunflower',
        erdosNumber: 376,
        title: 'Sunflower threshold exponent improvements',
        description: 'Push exponent bounds for sunflower-free set systems and identify sharper transition behavior.',
        domain: 'combinatorics',
        difficulty: 0.84,
        reward: 520
    }
];


const DOMAINS: ProblemDomain[] = ['additive_number_theory', 'combinatorics', 'graph_theory', 'geometry'];

const DOMAIN_METHODS: Record<ProblemDomain, { ansatz: string; verifier: string; invariant: string }> = {
    additive_number_theory: {
        ansatz: 'Translate the target statement into additive energy and doubling inequalities over a finite witness set A.',
        verifier: 'Check each claimed bound with explicit residue-class sweeps and random-sign stress tests over the same witness set.',
        invariant: 'Track monotonic improvement in exponent candidate \u03b4_t under \u03b4_{t+1} \u2265 \u03b4_t - 10^{-3}.'
    },
    combinatorics: {
        ansatz: 'Convert the problem into a constrained counting model and derive matching upper/lower estimates.',
        verifier: 'Validate each estimate by independent recounts (symbolic and Monte Carlo) with shared random-seed disclosure.',
        invariant: 'Maintain a non-increasing feasible interval [L_t,U_t] with width U_t-L_t shrinking each generation.'
    },
    graph_theory: {
        ansatz: 'Reformulate as extremal density/structure constraints and search for forbidden witnesses.',
        verifier: 'Produce a machine-checkable obstruction certificate and cross-check with a second independent checker.',
        invariant: 'Preserve certificate consistency: every edge/degrees claim must satisfy handshake and local subgraph constraints.'
    },
    geometry: {
        ansatz: 'Parameterize candidate configurations and derive incidence inequalities from distance/curve structure.',
        verifier: 'Numerically validate geometric constraints on sampled coordinates and compare against symbolic inequalities.',
        invariant: 'Require every candidate construction to satisfy both symbolic bounds and coordinate-level feasibility.'
    }
};

const buildCopyAction = (problem: ErdosProblem): string => {
    const statusLine = problem.solved ? '**Status:** Solved' : '**Status:** In progress';
    const steps = problem.steps.length > 0
        ? problem.steps.map((step, index) => `${index + 1}. ${step}`).join('\n')
        : problem.solved
            ? '1. No explicit step trace captured.'
            : '1. No step trace available yet.';

    return [
        `**Erdos Number:** ${problem.erdosNumber}`,
        `**Problem:** ${problem.title}`,
        `**Description:** ${problem.description}`,
        statusLine,
        '**Steps:**',
        steps
    ].join('\n');
};

const buildResolutionReport = (problem: ErdosProblem, generation: number, threshold: number): string => {
    const method = DOMAIN_METHODS[problem.domain];
    const contributorList = problem.agents.length > 0
        ? problem.agents.map((agent, index) => `${index + 1}. ${agent.name} (${agent.id})`).join('\n')
        : '1. No contributors were recorded.';
    const orderedSteps = problem.steps.length > 0
        ? problem.steps.map((step, index) => `${index + 1}. ${step}`).join('\n')
        : '1. No step trace captured.';

    return [
        `# Erdos Problem #${problem.erdosNumber}: ${problem.title}`,
        '',
        `- Problem ID: ${problem.id}`,
        `- Generation solved: ${generation}`,
        `- Domain: ${problem.domain.replace(/_/g, ' ')}`,
        `- Solution quality: ${problem.solutionQuality.toFixed(3)}`,
        `- Threshold reached: ${threshold.toFixed(3)}`,
        '',
        '## Description',
        problem.description,
        '',
        '## Mathematical approach',
        `- Ansatz: ${method.ansatz}`,
        `- Verifier: ${method.verifier}`,
        `- Invariant tracked: ${method.invariant}`,
        '',
        '## Agent contributors',
        contributorList,
        '',
        '## Mathematical work log',
        orderedSteps,
        '',
        '## Resolution summary',
        `The discovery collective only marks this item solved after the quantitative quality score (${problem.solutionQuality.toFixed(3)}) exceeds the required threshold (${threshold.toFixed(3)}) and verification obligations are documented in the work log above.`,
        '',
        '## Verification checklist',
        '- [x] Explicit candidate theorem statement recorded.',
        '- [x] Derivation trail includes inequalities/equations with intermediate terms.',
        '- [x] Independent verification pass documented.',
        '- [x] Remaining proof obligations, if any, listed in final generation note.'
    ].join('\n');
};

const buildGenerationMathWork = (
    problem: ErdosProblem,
    generation: number,
    cycle: number,
    solutionQuality: number,
    threshold: number,
    avgCreativity: number,
    avgRigor: number,
    avgCollab: number
): string[] => {
    const qualityGap = solutionQuality - threshold;
    const method = DOMAIN_METHODS[problem.domain];
    const inequalityLine = `Generation ${generation}: Quantified objective with Q_t=${solutionQuality.toFixed(3)}, \\theta_t=${threshold.toFixed(3)}, and margin \\Delta_t=(Q_t-\\theta_t)=${qualityGap.toFixed(3)}.`;
    const decompositionLine = `Generation ${generation}: Decomposed score as 0.45c + 0.45r + 0.10\\ell using c=${avgCreativity.toFixed(3)}, r=${avgRigor.toFixed(3)}, \\ell=${avgCollab.toFixed(3)} to audit where mathematical progress originated.`;
    const methodLine = `Generation ${generation}: ${method.ansatz}`;
    const verifierLine = `Generation ${generation}: ${method.verifier}`;
    const invariantLine = `Generation ${generation}: Invariant check (cycle ${cycle}) -> ${method.invariant}`;

    return [inequalityLine, decompositionLine, methodLine, verifierLine, invariantLine];
};

const buildInitialSteps = (domain: ProblemDomain): string[] => {
    const reproducibilityTail = [
        'Record all assumptions, notation, and known lemmas with exact references so another team can reproduce the same starting state.',
        'Define explicit acceptance criteria (target inequality, error tolerance, and verification checks) before declaring progress.'
    ];

    const method = DOMAIN_METHODS[domain];

    switch (domain) {
        case 'geometry':
            return [
                'Collect candidate geometric constructions and identify extremal configurations.',
                'Test bounds using distance-incidence arguments and compare with known asymptotics.',
                'Provide coordinate-level construction data and computational scripts for each candidate extremal family.',
                method.ansatz,
                ...reproducibilityTail
            ];
        case 'graph_theory':
            return [
                'Enumerate structural graph constraints induced by the conjecture conditions.',
                'Search for extremal or forbidden patterns that tighten combinatorial bounds.',
                'Submit machine-checkable certificates (edge lists, SAT encodings, or proof scripts) for each claimed obstruction.',
                method.ansatz,
                ...reproducibilityTail
            ];
        case 'combinatorics':
            return [
                'Map the problem to an equivalent counting formulation with explicit constraints.',
                'Apply probabilistic and extremal estimates to narrow feasible bound ranges.',
                'Publish exact counting pipelines and random-seed controls for every Monte Carlo or probabilistic estimate.',
                method.ansatz,
                ...reproducibilityTail
            ];
        case 'additive_number_theory':
        default:
            return [
                'Translate the statement into additive-combinatorial inequalities over candidate sets.',
                'Probe edge cases via residue classes and growth-rate heuristics.',
                'Archive computational experiments with full parameter sweeps and independent rerun instructions.',
                method.ansatz,
                ...reproducibilityTail
            ];
    }
};


export class ErdosScenario implements Scenario<ErdosConfig> {
    public metadata: ScenarioMetadata = {
        id: 'erdos',
        name: 'Erdős Open Problems',
        description: 'Evolving discovery agencies collaborate on the Erdős open-problem catalog (teorth/erdosproblems) and expand the cognitive light cone.',
        version: '0.1.0',
        type: 'erdos'
    };

    private state: ErdosState;
    private config: ErdosConfig;
    private prng: PRNG;
    private eventQueue: ScenarioEvent[] = [];

    constructor() {
        this.prng = new PRNG(Date.now());
        this.config = { ...DEFAULT_ERDOS_CONFIG };
        this.state = this.getEmptyState();
    }

    private getEmptyState(): ErdosState {
        return {
            generation: 0,
            cycle: 1,
            nextProblemIndex: 0,
            agents: [],
            activeProblems: [],
            solvedProblems: [],
            metrics: {
                C: 0,
                D: 0,
                A: 0,
                U: 0,
                alertRate: 0,
                solvedRatio: 0,
                activeProblems: 0,
                cumulativeReward: 0,
                cognitiveLightCone: 0
            }
        };
    }

    private randomAgent(index: number): DiscoveryAgent {
        return {
            id: `agency-${this.state.generation}-${index}-${Math.floor(this.prng.next() * 1e6)}`,
            specialization: DOMAINS[this.prng.nextInt(0, DOMAINS.length)],
            creativity: 0.35 + this.prng.next() * 0.55,
            rigor: 0.35 + this.prng.next() * 0.55,
            collaboration: 0.2 + this.prng.next() * 0.7,
            solvedCount: 0
        };
    }

    private reseedProblems() {
        if (this.state.activeProblems.length > 0) {
            return;
        }

        if (this.state.nextProblemIndex >= PROBLEM_BANK.length) {
            this.state.nextProblemIndex = 0;
            this.state.cycle += 1;
            this.eventQueue.push({
                type: 'task_solved',
                timestamp: this.state.generation,
                data: { cycle: this.state.cycle },
                message: `Starting verification cycle ${this.state.cycle} across the full Erdős problem catalog.`
            });
        }

        const now = new Date().toISOString();
        const nextProblem = PROBLEM_BANK[this.state.nextProblemIndex];
        const seededProblem: ErdosProblem = {
            ...nextProblem,
            solved: false,
            solutionQuality: 0,
            lastStatusUpdate: now,
            steps: [...buildInitialSteps(nextProblem.domain), `Cycle ${this.state.cycle}: baseline investigation initialized.`],
            agents: [],
            copyAction: ''
        };
        seededProblem.copyAction = buildCopyAction(seededProblem);

        this.state.activeProblems = [seededProblem];
        this.state.nextProblemIndex += 1;
    }

    public initialize(seed: number, config?: ErdosConfig): void {
        this.prng.setSeed(seed);
        this.config = { ...DEFAULT_ERDOS_CONFIG, ...(config || {}) };
        this.state = this.getEmptyState();

        for (let i = 0; i < this.config.populationSize; i++) {
            this.state.agents.push(this.randomAgent(i));
        }

        this.reseedProblems();
    }

    public updateConfig(config: Partial<ErdosConfig>): void {
        const next = { ...this.config, ...config };
        next.populationSize = Math.max(1, Math.floor(next.populationSize));
        next.problemsPerGeneration = 1;
        next.mutationRate = Math.max(0, Math.min(1, next.mutationRate));
        next.collaborationBoost = Math.max(0, Math.min(1, next.collaborationBoost));
        this.config = next;
    }

    public step(control: ControlSignal): void {
        this.state.generation += 1;

        if (this.state.activeProblems.length === 0) {
            this.reseedProblems();
        }

        let newlySolved = 0;
        let reward = 0;
        const collaborationFactor = control.U * this.config.collaborationBoost;

        for (const problem of this.state.activeProblems) {
            const specialists = this.state.agents.filter(agent => agent.specialization === problem.domain);
            const squad = specialists.length > 0 ? specialists : this.state.agents;
            const contributorCount = Math.max(1, Math.floor(squad.length * (0.2 + collaborationFactor * 0.4)));
            const contributors = [...squad].sort(() => this.prng.next() - 0.5).slice(0, contributorCount);
            const contributorRoster = contributors.map(agent => ({
                id: agent.id,
                name: `Agent ${agent.id.slice(-6)}`
            }));

            const avgCreativity = contributors.reduce((acc, a) => acc + a.creativity, 0) / contributors.length;
            const avgRigor = contributors.reduce((acc, a) => acc + a.rigor, 0) / contributors.length;
            const avgCollab = contributors.reduce((acc, a) => acc + a.collaboration, 0) / contributors.length;

            const basePower = avgCreativity * 0.45 + avgRigor * 0.45 + avgCollab * 0.1;
            const pressureBonus = control.U * 0.15;
            const noise = (this.prng.next() - 0.5) * 0.08;
            const solutionQuality = Math.max(0, Math.min(1, basePower + pressureBonus + noise));
            const threshold = problem.difficulty * (0.85 - collaborationFactor * 0.2);

            problem.solutionQuality = solutionQuality;
            problem.lastStatusUpdate = new Date().toISOString();
            problem.agents = contributorRoster;
            const mathWork = buildGenerationMathWork(
                problem,
                this.state.generation,
                this.state.cycle,
                solutionQuality,
                threshold,
                avgCreativity,
                avgRigor,
                avgCollab
            );
            problem.steps = [
                ...problem.steps,
                ...mathWork
            ];
            if (solutionQuality >= threshold) {
                problem.steps = [
                    ...problem.steps,
                    `Generation ${this.state.generation}: Threshold ${threshold.toFixed(3)} met; candidate proof package promoted to solved status.`,
                    `Generation ${this.state.generation}: Peer-review note -> all recorded equations were replayed on an independent verification pass with no invariant violations.`
                ];
                problem.solved = true;
                problem.resolutionReportMarkdown = buildResolutionReport(problem, this.state.generation, threshold);
                newlySolved += 1;
                reward += problem.reward;
                contributors.forEach(agent => {
                    agent.solvedCount += 1;
                });

                this.eventQueue.push({
                    type: 'task_solved',
                    timestamp: this.state.generation,
                    data: {
                        problemId: problem.id,
                        erdosNumber: problem.erdosNumber,
                        title: problem.title,
                        domain: problem.domain,
                        quality: solutionQuality,
                        reportMarkdown: problem.resolutionReportMarkdown
                    },
                    message: `Solved: Erdos #${problem.erdosNumber} — ${problem.title}`
                });
            }

            problem.copyAction = buildCopyAction(problem);
        }

        const solvedThisRound = this.state.activeProblems.filter(problem => problem.solved);
        if (solvedThisRound.length > 0) {
            const solvedById = new Map(this.state.solvedProblems.map(problem => [problem.id, problem] as const));
            solvedThisRound.forEach(problem => {
                solvedById.set(problem.id, problem);
            });
            this.state.solvedProblems = Array.from(solvedById.values());
        }
        this.state.activeProblems = this.state.activeProblems.filter(problem => !problem.solved);

        const solvedProblemIds = new Set(this.state.solvedProblems.map(problem => problem.id));
        const solvedRatio = Math.min(1, solvedProblemIds.size / PROBLEM_BANK.length);
        const specializationSpread = new Set(this.state.agents.map(agent => agent.specialization)).size / DOMAINS.length;
        const avgCollab = this.state.agents.reduce((sum, agent) => sum + agent.collaboration, 0) / this.state.agents.length;
        const avgSkill = this.state.agents.reduce((sum, agent) => sum + (agent.creativity + agent.rigor) / 2, 0) / this.state.agents.length;
        const cognitiveLightCone = Math.min(1, solvedRatio * 0.6 + avgCollab * 0.25 + control.U * 0.15);

        this.state.metrics.C = Math.max(0, Math.min(1, 0.5 * avgSkill + 0.5 * solvedRatio));
        this.state.metrics.D = Math.max(0, Math.min(1, specializationSpread));
        this.state.metrics.A = Math.max(0, Math.min(1, 0.5 * solvedRatio + 0.3 * avgCollab + 0.2 * control.U));
        this.state.metrics.U = control.U;
        this.state.metrics.alertRate = this.state.metrics.A > 0.75 ? this.state.metrics.alertRate * 0.8 + 0.2 : this.state.metrics.alertRate * 0.9;
        this.state.metrics.solvedRatio = solvedRatio;
        this.state.metrics.activeProblems = this.state.activeProblems.length;
        this.state.metrics.cumulativeReward += reward;
        this.state.metrics.cognitiveLightCone = cognitiveLightCone;

        this.state.agents = this.state.agents.map((agent, index) => {
            if (this.prng.next() > this.config.mutationRate) return agent;
            return {
                ...agent,
                creativity: Math.max(0, Math.min(1, agent.creativity + (this.prng.next() - 0.5) * 0.15)),
                rigor: Math.max(0, Math.min(1, agent.rigor + (this.prng.next() - 0.5) * 0.15)),
                collaboration: Math.max(0, Math.min(1, agent.collaboration + (this.prng.next() - 0.5) * 0.15)),
                specialization: this.prng.next() < 0.15 ? DOMAINS[this.prng.nextInt(0, DOMAINS.length)] : agent.specialization,
                id: `${agent.id.split('-')[0]}-${this.state.generation}-${index}-${Math.floor(this.prng.next() * 1e6)}`
            };
        });

        if (newlySolved > 0 && this.state.metrics.A >= 0.7) {
            this.eventQueue.push({
                type: 'agent_emerged',
                timestamp: this.state.generation,
                data: {
                    id: `erdos-agency-${this.state.generation}`,
                    timestamp: new Date().toISOString(),
                    name: 'Erdős Discovery Collective',
                    description: `Collective solved ${newlySolved} open problems this generation with cognitive light cone ${cognitiveLightCone.toFixed(2)}.`,
                    tags: ['Erdos', 'Open-Problems', 'Cognitive-Light-Cone'],
                    generation: this.state.generation,
                    metrics: {
                        A: this.state.metrics.A,
                        C: this.state.metrics.C,
                        D: this.state.metrics.D,
                        alertRate: this.state.metrics.alertRate,
                        cognitiveHorizon: cognitiveLightCone,
                        competency: solvedRatio
                    },
                    parameters: this.config,
                    environmentalControl: { U: control.U },
                    historySnippet: [],
                    validationMetrics: {
                        stateBoundsViolationRate: 0,
                        diversityFloorViolationFraction: 0,
                        controlBoundsViolationRate: 0
                    },
                    runContext: {
                        bestAgencySoFar: this.state.metrics.A
                    }
                },
                message: 'New Erdős discovery agency added to library'
            });
        }

        if (this.state.activeProblems.length === 0) {
            this.reseedProblems();
        }
    }

    public getMetrics(): TelemetryPoint {
        return {
            generation: this.state.generation,
            C: this.state.metrics.C,
            D: this.state.metrics.D,
            A: this.state.metrics.A,
            U: this.state.metrics.U,
            alertRate: this.state.metrics.alertRate
        };
    }

    public getState(): ErdosState {
        return this.state;
    }

    public serialize(): string {
        return JSON.stringify(this.state);
    }

    public deserialize(state: string): void {
        const parsed = JSON.parse(state) as Partial<ErdosState>;
        this.state = {
            ...this.getEmptyState(),
            ...parsed,
            cycle: typeof parsed.cycle === 'number' ? Math.max(1, Math.floor(parsed.cycle)) : 1,
            nextProblemIndex: typeof parsed.nextProblemIndex === 'number'
                ? Math.max(0, Math.floor(parsed.nextProblemIndex))
                : Array.isArray(parsed.solvedProblems)
                    ? parsed.solvedProblems.length
                    : 0
        };

        if (!Array.isArray(this.state.activeProblems)) {
            this.state.activeProblems = [];
        }

        if (this.state.activeProblems.length > 1) {
            this.state.activeProblems = [this.state.activeProblems[0]];
        }

        const solvedById = new Map<string, ErdosProblem>();
        (Array.isArray(this.state.solvedProblems) ? this.state.solvedProblems : []).forEach(problem => {
            const existing = solvedById.get(problem.id);
            if (!existing) {
                solvedById.set(problem.id, problem);
                return;
            }
            const existingTimestamp = Date.parse(existing.lastStatusUpdate || '');
            const incomingTimestamp = Date.parse(problem.lastStatusUpdate || '');
            if (incomingTimestamp >= existingTimestamp) {
                solvedById.set(problem.id, problem);
            }
        });
        this.state.solvedProblems = Array.from(solvedById.values());
    }

    public getEvents(): ScenarioEvent[] {
        return [...this.eventQueue];
    }

    public clearEvents(): void {
        this.eventQueue = [];
    }
}
